# 重构时间轴事件类型架构

## Context（背景）

当前时间轴系统存在两个冗余的事件类型：
- `MitigationAssignment` - 用于存储减伤技能使用记录
- `ReplayStateEvent` - 用于存储 FFLogs 导入的状态事件

这两个类型的命名不够清晰，且与实际的事件概念（DamageEvent, CastEvent, StatusEvent）不一致。

根据探索结果，我们发现：
1. **编辑模式**：用户手动规划减伤，需要存储技能使用记录（CastEvent），通过 executor 模拟产生 StatusEvent
2. **回放模式**：从 FFLogs 导入，直接获取真实的 StatusEvent，无需 executor 模拟

因此，我们需要重构为统一的事件类型架构：
- `DamageEvent` - 伤害事件
- `CastEvent` - 技能使用事件（任何模式都有）
- `StatusEvent` - 状态事件（回放模式直接存储，编辑模式动态生成）

## 重构方案

### 1. 类型定义重构

#### 1.1 将 `CastEvent` 从 fflogsImporter 移到 timeline.ts
```typescript
// src/types/timeline.ts

/**
 * 技能使用事件
 */
export interface CastEvent {
  /** 事件 ID */
  id: string
  /** 技能 ID */
  actionId: number
  /** 使用时间（秒） */
  time: number
  /** 使用者玩家 ID */
  playerId: number
  /** 使用者职业 */
  job: Job
  /** 目标玩家 ID（可选，用于单体技能） */
  targetPlayerId?: number
}
```

**字段说明**：
- 保留 `MitigationAssignment` 的所有业务字段（id, job）
- 重命名 `actionId`（原 `abilityGameID`）
- 时间单位统一为秒（原 `timestamp` 是毫秒）
- 移除 `sourceIsFriendly`（编辑器中只有友方技能）

#### 1.2 重命名 `ReplayStateEvent` 为 `StatusEvent`
```typescript
// src/types/timeline.ts

/**
 * 状态事件（用于回放模式）
 */
export interface StatusEvent {
  /** 事件类型 */
  type: 'applybuff' | 'removebuff' | 'applydebuff' | 'removedebuff'
  /** 时间戳（相对战斗开始，毫秒） */
  timestamp: number
  /** 状态 ID */
  statusId: number
  /** 来源玩家 ID */
  sourcePlayerId?: number
  /** 目标玩家 ID */
  targetPlayerId?: number
  /** 目标实例 */
  targetInstance?: number
}
```

**字段说明**：
- 重命名 `abilityGameID` → `statusId`（更清晰）
- 重命名 `sourceID` → `sourcePlayerId`（一致性）
- 重命名 `targetID` → `targetPlayerId`（一致性）

#### 1.3 更新 `Timeline` 接口
```typescript
// src/types/timeline.ts

export interface Timeline {
  id: string
  name: string
  encounter: Encounter
  composition: Composition
  phases: Phase[]

  /** 伤害事件列表 */
  damageEvents: DamageEvent[]

  /** 技能使用事件列表（编辑模式和回放模式都有） */
  castEvents: CastEvent[]

  /** 状态事件列表（仅回放模式，从 FFLogs 导入） */
  statusEvents?: StatusEvent[]

  /** 是否为回放模式 */
  isReplayMode?: boolean

  // 移除以下字段：
  // mitigationAssignments: MitigationAssignment[]  ❌
  // replayStateEvents?: ReplayStateEvent[]         ❌
  // mitigationPlan?: MitigationPlan                ❌

  createdAt: string
  updatedAt: string
}
```

### 2. 数据流重构

#### 2.1 编辑模式数据流
```
用户添加技能
    ↓
创建 CastEvent（包含 actionId, time, playerId, job）
    ↓
存储到 Timeline.castEvents[]
    ↓
getPartyStateAtTime(time)
    ↓
遍历 castEvents，执行 executor
    ↓
动态生成 MitigationStatus[]（运行时状态）
    ↓
构建 PartyState
    ↓
计算减伤效果
```

#### 2.2 回放模式数据流
```
FFLogs 导入
    ↓
parseCastEvents() → CastEvent[]
parseStatusEvents() → StatusEvent[]
parseDamageEvents() → DamageEvent[]
    ↓
存储到 Timeline.castEvents[] 和 Timeline.statusEvents[]
    ↓
getPartyStateAtTime(time)
    ↓
遍历 statusEvents，重放状态变化
    ↓
构建 PartyState（使用真实状态数据）
    ↓
计算减伤效果
```

### 3. 关键文件修改

#### 3.1 类型定义
**文件**: `src/types/timeline.ts`
- 添加 `CastEvent` 接口
- 重命名 `ReplayStateEvent` → `StatusEvent`
- 更新 `Timeline` 接口
- 移除 `MitigationAssignment` 接口
- 移除 `MitigationPlan` 接口

#### 3.2 FFLogs 导入器
**文件**: `src/utils/fflogsImporter.ts`
- 移除 `CastEvent` 定义（移到 timeline.ts）
- 重命名 `parseStatusEvents` 返回类型为 `StatusEvent[]`
- 重命名 `parseMitigationAssignments` → `parseCastEventsFromFFLogs`
- 更新 `parseCastEvents` 返回 `CastEvent[]`（包含完整字段）

#### 3.3 时间轴存储
**文件**: `src/store/timelineStore.ts`
- 重命名 `addAssignment` → `addCastEvent`
- 重命名 `updateAssignment` → `updateCastEvent`
- 重命名 `removeAssignment` → `removeCastEvent`
- 更新 `buildPartyStateFromReplayEvents` → `buildPartyStateFromStatusEvents`
- 更新 `getPartyStateAtTime` 使用新的字段名

#### 3.4 时间轴组件
**文件**: `src/components/Timeline/`
- `MitigationAssignmentIcon.tsx` → `CastEventIcon.tsx`
- `SkillTracksCanvas.tsx` - 更新遍历 `timeline.castEvents`
- `index.tsx` - 更新拖拽逻辑使用 `CastEvent`

#### 3.5 计算器
**文件**: `src/utils/mitigationCalculator.ts`
- 更新 `getActiveEffects` 接收 `CastEvent[]`
- 更新 `validateCooldown` 接收 `CastEvent[]`
- 更新 `canUseActionAt` 接收 `CastEvent[]`

#### 3.6 导入对话框
**文件**: `src/components/ImportFFLogsDialog.tsx`
- 更新导入逻辑使用新的类型名
- 设置 `timeline.castEvents` 和 `timeline.statusEvents`

### 4. 迁移策略

#### 4.1 向后兼容
为了支持旧数据，需要在 `timelineStorage.ts` 中添加迁移逻辑：

```typescript
function migrateTimeline(timeline: any): Timeline {
  // 迁移 mitigationAssignments → castEvents
  if (timeline.mitigationAssignments && !timeline.castEvents) {
    timeline.castEvents = timeline.mitigationAssignments.map((assignment: any) => ({
      id: assignment.id,
      actionId: assignment.actionId,
      time: assignment.time,
      playerId: assignment.playerId,
      job: assignment.job,
      targetPlayerId: assignment.targetPlayerId,
      damageEventId: assignment.damageEventId,
    }))
    delete timeline.mitigationAssignments
  }

  // 迁移 replayStateEvents → statusEvents
  if (timeline.replayStateEvents && !timeline.statusEvents) {
    timeline.statusEvents = timeline.replayStateEvents.map((event: any) => ({
      type: event.type,
      timestamp: event.timestamp,
      statusId: event.abilityGameID,
      sourcePlayerId: event.sourceID,
      targetPlayerId: event.targetID,
      targetInstance: event.targetInstance,
    }))
    delete timeline.replayStateEvents
  }

  return timeline
}
```

#### 4.2 测试更新
需要更新以下测试文件：
- `src/utils/fflogsImporter.test.ts` - 更新类型名和函数名
- `src/utils/mitigationCalculator.test.ts` - 更新 `CastEvent` 使用
- `src/store/timelineStore.test.ts` - 更新方法名

### 5. 实施步骤

1. **Phase 1: 类型定义**
   - 在 `timeline.ts` 中添加 `CastEvent` 和 `StatusEvent`
   - 标记 `MitigationAssignment` 和 `ReplayStateEvent` 为 `@deprecated`

2. **Phase 2: 工具函数**
   - 更新 `fflogsImporter.ts` 使用新类型
   - 添加数据迁移函数到 `timelineStorage.ts`

3. **Phase 3: 存储层**
   - 更新 `timelineStore.ts` 的方法名和类型
   - 更新 `getPartyStateAtTime` 逻辑

4. **Phase 4: UI 组件**
   - 重命名 `MitigationAssignmentIcon` → `CastEventIcon`
   - 更新所有组件使用新类型

5. **Phase 5: 计算器**
   - 更新 `mitigationCalculator.ts` 使用 `CastEvent`

6. **Phase 6: 测试**
   - 更新所有测试文件
   - 运行测试确保通过
   - 测试数据迁移逻辑

7. **Phase 7: 清理**
   - 移除 `@deprecated` 的旧类型
   - 移除旧的测试代码
   - 更新文档

### 6. 验证计划

#### 6.1 单元测试
- 运行 `pnpm test:run` 确保所有测试通过
- 特别关注：
  - `fflogsImporter.test.ts` - 解析逻辑
  - `mitigationCalculator.test.ts` - 计算逻辑
  - `timelineStore.test.ts` - 状态管理

#### 6.2 类型检查
- 运行 `pnpm exec tsc --noEmit` 确保无类型错误

#### 6.3 功能测试
1. **编辑模式测试**
   - 创建新时间轴
   - 添加伤害事件
   - 添加减伤技能
   - 拖拽调整时间
   - 删除技能
   - 保存和加载

2. **回放模式测试**
   - 导入 FFLogs 数据
   - 验证技能和状态正确导入
   - 验证减伤计算正确
   - 切换回编辑模式

3. **数据迁移测试**
   - 使用旧版本数据（包含 `mitigationAssignments`）
   - 加载时应自动迁移为 `castEvents`
   - 验证功能正常

### 7. 风险和注意事项

1. **数据迁移风险**
   - 用户的旧数据需要正确迁移
   - 建议在迁移前备份 LocalStorage

2. **组件重命名**
   - 大量文件需要修改
   - 需要仔细检查所有引用

3. **时间单位转换**
   - `CastEvent.time` 是秒
   - `StatusEvent.timestamp` 是毫秒
   - 需要在转换时注意单位

4. **回放模式兼容性**
   - 确保回放模式的状态计算逻辑正确
   - 测试 FFLogs 导入功能

## 总结

这次重构将简化时间轴的事件类型架构，使其更加清晰和一致：
- `DamageEvent` - 伤害事件
- `CastEvent` - 技能使用事件（替代 MitigationAssignment）
- `StatusEvent` - 状态事件（替代 ReplayStateEvent）

重构后的架构更符合实际的游戏事件模型，且两种模式（编辑/回放）的数据流更加清晰。
